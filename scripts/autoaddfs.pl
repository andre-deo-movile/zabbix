#!/usr/bin/perl
#	 A script to parse fstab and create items and triggers inside Zabbix NMS
#	 This is a work in progress, so, read the autoaddfs.README and cross your fingers
#    and don't blame me if this mess up your zabbix configuration. 
#
#    Copyright (C) <2011>  <Jefferson Alexandre dos Santos>, <jefferson.alexandre [at] gmail [dot] com> 
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


use JSON ;
use JSON::RPC::Client ;
use Data::Dumper ;
use strict ;
use warnings ; 

my @items ; 
#Get Itens to be created before all hard work ;) 
my $input_fh, "</etc/fstab " 
	or die "Cant open file" ;
while ( my $line = <$input_fh> ) {
	#Super killer regex  stolen from Gandalf ( @dcsobral ) :-)
	if ( $line =~ /^\s*[^#]\S*\s+(\S+)\s+(ext|nfs)/  ) {
			push @items, $1  ;
	}
}
close $input_fh ;

#JSON Authentication and server variables - Adjust for your environment
my ($zabbix, $api_user, $api_passwd) = ("http://zabbix.homelinux/zabbix/api_jsonrpc.php", "apiuser", "apipass" ) ;

#Setting user agent
my $client = new JSON::RPC::Client ;	
$client->ua->credentials("$zabbix", 'Transmission RPC Server', $api_user ) ;

#Setting Authentication 
my	$auth  = {
	jsonrpc  => "2.0",
	method   => "user.authenticate",
	params   => {
		user	 => "$api_user",
		password => "$api_passwd",
  	},
	id => 1,
} ; 

#Execute authentication and retrieve auth string
my $authentication = $client->call($zabbix,$auth);
$auth = $authentication->result ;

#FQDN generated by system command (yes, my zabbix hosts are named by fqdn) 
my $fqdn = `/bin/hostname -f` ;
chomp ($fqdn) ;

#Get the hostid 
my $hostid = get_hostid($zabbix,$auth,$client,$fqdn) ;

#I'm able to recover a application id for filesystem, or whatever I need, 
#but I can't create item setting applications (like documentation says.) 
#Maybe a Zabbix API bug, maybe zombies joking with me. Who knows?

#my  $application   = "Filesystem" ;
#my  $applicationid = get_applicationid($zabbix,$auth,$client,$hostid,$application) ;

foreach my $item  (@items) {
	chomp ($item)  ;
	# A little homenage to my friend Gandalf, who patientily had show nice
	# things and gave me nice ideas. 
	print "Calling the wizards to execute all hard work. =) \n" ; 
	my $itemid = check_existence($zabbix,$auth,$client,$item,$hostid) ; 
	unless ($itemid) { 
		my $created_itemid = create_item($zabbix,$auth,$client,$item,$hostid) ; 
		#I will put this ugly part into a hash someday...
		my @value    = qw(20 10) ;
		my @priority = qw(2 3) ;
		create_trigger($zabbix,$auth,$client,$item,$fqdn,$value[0],$priority[0]) ;
		create_trigger($zabbix,$auth,$client,$item,$fqdn,$value[1],$priority[1]) ;
	} 
}

exit 0 ;	

#The wizards :-)

sub get_hostid {
	my ($zabbix, $auth, $client, $fqdn) = @_ ;
	my $query	= {	
		jsonrpc => "2.0",
		method  => "host.get",
		params  => {
    		output => "extend",
    		filter => {
        		host => $fqdn, 
        		},
    		},
		auth => $auth,
		id => 1,
	} ;
	my $key = "\"hostid\"" ;
	my $hostid = parse($zabbix,$client,$query,$key) ;
	unless ($hostid) {
		print "Unable to find  $fqdn in Zabbix Server\n" ; 
		print "Exiting before the room  explode :-) \n" ; 
		exit 0 ; }
	return $hostid ;
}

sub get_applicationid {
	my ( $zabbix, $auth, $client, $hostid, $application ) = @_ ;
	chomp ($application) ;
	my $query	= {	
		jsonrpc => "2.0",
		method  => "application.get",
		params  => {
	   		output => "extend",
			filter => {
				hostid => $hostid,
			},
			search => {
				name => $application,	
			},
		},
		auth => $auth,
		id => 1,
	} ;
	my $key = "\"applicationid\"" ;
	my $applicationid = parse($zabbix,$client,$query,$key) ;
	return $applicationid ;
}
sub check_existence {
	my ($zabbix, $auth, $client, $item, $hostid) = @_ ;
	my $query	= {	
		jsonrpc => "2.0",
		method  => "item.get",
		params  => {
	   		output => "extend",
			filter => {
				hostid => $hostid,
			},
			search => {
				key_  => "vfs.fs.size[$item,pfree]",
			},
		},
		auth => $auth,
		id => 1,
	} ;
	my $key = "\"itemid\"" ;
	my $itemid = parse($zabbix,$client,$query,$key) ;
	if ($itemid) {
		print " The $item already created. Run before the zombies eat your brain\n" ; 
	}
	else {
		return $itemid ;
	}	
} 

sub create_item {
	my ( $zabbix, $auth, $client, $item, $hostid ) = @_ ;
	my $query   = { 
		jsonrpc => "2.0",
		method  => "item.create",
		params  => {
			description    => "Free Disk Space on \$1 in %",
			key_  	       => "vfs.fs.size[$item,pfree]",
			hostid 	       => $hostid,
			value_type     => 0,
			delay	       => 3600,
		},
		auth => $auth,
		id => 1,
	} ;
	my $key  = "\"itemids\"" ;
	my $itemid = parse($zabbix,$client,$query,$key) ;
	return $itemid ;
}

sub create_trigger {
	my ($zabbix, $auth, $client, $item, $fqdn, $value, $priority ) = @_ ;
	my $query  = {
		jsonrpc => "2.0",
		method  => "trigger.create",
		params  => {
			description => "Low free diskspace on {HOSTNAME} volume $item < $value",
			expression  => "{$fqdn:vfs.fs.size[$item,pfree].last(0)}<$value",
			status      => 0,
			priority	=> $priority,
		},
		auth => $auth,
		id => 1,
	} ;
	my $key = "\"triggerid\"" ;
	my $triggerid = parse($zabbix,$client,$query,$key) ;
	return $triggerid ;
}

sub parse {
	my ($zabbix, $client, $query, $key) = @_ ;
	my $json_query  = $client->call($zabbix,$query);
	my $json_result = $json_query->result ;
	my @result = ( split /,/, (encode_json $json_result)) ;
	foreach my $returned_item (@result) {
		if ($returned_item =~ /$key/) {
			$returned_item =~ s/\D//g ;
			return $returned_item ;	
		}
	}
}
